"""
EX3P1SP22.py – GUI for Exam‑3 Problem 1 (Transient RLC network)

This version relies ENTIRELY on the widgets defined in Problem1.ui.
Nothing is created twice; the only “code‑side” widget is the
Matplotlib canvas that we insert under the existing group‑box.
"""

# --------------------------------------------------------------------
from typing import Callable
import sys
import numpy as np
from scipy.integrate import solve_ivp
from PyQt5 import QtWidgets as qtw
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas
from matplotlib.figure import Figure

from Problem1 import Ui_Form          # generated by pyuic5
# --------------------------------------------------------------------


def v_source(A: float, w: float, phi: float) -> Callable[[float], float]:
    return lambda t: A * np.sin(w * t + phi)


def rlc_ode(t, y, R, L, C, vsrc):
    iL, vC = y
    return [(vsrc(t) - vC) / L, (iL - vC / R) / C]


class MainWindow(qtw.QWidget, Ui_Form):
    def __init__(self):
        super().__init__()
        self.setupUi(self)               # all Designer widgets now exist
        self.resize(900, 650)            # open larger

        # ----------------------------------------------------------------
        # 1.  Embed a Matplotlib canvas just *below* the group‑box.
        #     main_VerticalLayout already owns plotWidget (top) —
        #     we’ll add the canvas right after that.
        # ----------------------------------------------------------------
        self.fig = Figure(figsize=(6, 4), tight_layout=True)
        self.ax  = self.fig.add_subplot(1, 1, 1)
        self.canvas = Canvas(self.fig)
        self.main_VerticalLayout.addWidget(self.canvas)   # <‑‑ key line
        self.resize(920,920) #image isn't fully shown otherwise
        # ----------------------------------------------------------------
        # 2.  Hook up the Simulate button that Designer gave us.
        # ----------------------------------------------------------------
        self.btn_run.clicked.connect(self.simulate)

        # (Defaults already set in .ui, so nothing else to do.)

    # --------------------------------------------------------------------
    # Core simulation + plotting
    # --------------------------------------------------------------------
    def simulate(self):
        try:
            R   = float(self.ed_R.text())
            L   = float(self.ed_L.text())
            C   = float(self.ed_C.text())
            A   = float(self.ed_A.text())
            w   = float(self.ed_w.text())
            phi = float(self.ed_phi.text())
        except ValueError:
            qtw.QMessageBox.warning(self, "Input error",
                                    "All parameters must be numeric.")
            return

        vfun = v_source(A, w, phi)

        t_end = 5 * 2 * np.pi / w           # simulate 5 periods
        t     = np.linspace(0, t_end, 2000)

        sol = solve_ivp(rlc_ode, (0, t_end), [0.0, 0.0],
                        t_eval=t, args=(R, L, C, vfun),
                        rtol=1e-8, atol=1e-10)

        iL, vC = sol.y
        i1 = vC / R
        i2 = C * np.gradient(vC, sol.t)

        self.ax.clear()
        self.ax.plot(sol.t, i1, label="i₁ (through R)")
        self.ax.plot(sol.t, i2, label="i₂ (through C)")
        self.ax.plot(sol.t, vC, '--', label="vC")
        self.ax.set_xlabel("time [s]")
        self.ax.set_title("Transient response")
        self.ax.grid(True)
        self.ax.legend()
        self.canvas.draw()


# -------------------------------------------------------------------------
if __name__ == "__main__":
    app = qtw.QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())
